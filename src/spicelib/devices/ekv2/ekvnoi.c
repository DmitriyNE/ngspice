/*
 * Author: 2000 Wladek Grabinski; EKV v2.6 Model Upgrade
 * Author: 1997 Eckhard Brass;    EKV v2.5 Model Implementation
 *     (C) 1990 Regents of the University of California. Spice3 Format
 */

#include "ngspice/ngspice.h"
#include "ekvdefs.h"
#include "ngspice/cktdefs.h"
#include "ngspice/iferrmsg.h"
#include "ngspice/noisedef.h"
#include "ngspice/suffix.h"

/*
 * EKVnoise (mode, operation, firstModel, ckt, data, OnDens)
 *    This routine names and evaluates all of the noise sources
 *    associated with MOSFET's.  It starts with the model *firstModel and
 *    traverses all of its insts.  It then proceeds to any other models
 *    on the linked list.  The total output noise density generated by
 *    all of the MOSFET's is summed with the variable "OnDens".
 */

extern void
NevalSrcEKV (
double ,
EKVmodel *,
EKVinstance *,
double *,
double *,
CKTcircuit *,
int ,
int ,
int ,
double);

int
EKVnoise (
int mode,
int operation,
GENmodel *genmodel,
CKTcircuit *ckt,
Ndata *data,
double *OnDens)
{
	EKVmodel *firstModel = (EKVmodel *) genmodel;
	EKVmodel *model;
	EKVinstance *inst;
	double leff;
	double weff;
	double coxSquared;
	double tempOnoise;
	double tempInoise;
	double noizDens[EKVNSRCS];
	double lnNdens[EKVNSRCS];
	int i;
	double temp;

	/* define the names of the noise sources */

    NOISEAN *job = (NOISEAN *) ckt->CKTcurJob;

	static char *EKVnNames[EKVNSRCS] = {       /* Note that we have to keep the order */
		"_rd",              /* noise due to rd */        /* consistent with the index definitions */
		"_rs",              /* noise due to rs */        /* in EKVdefs.h */
		"_id",              /* noise due to id */
		"_1overf",          /* flicker (1/f) noise */
		""                  /* total transistor noise */
	};

	for (model=firstModel; model != NULL; model=model->EKVnextModel) {

		coxSquared = model->EKVcox * model->EKVcox;

		for (inst=model->EKVinstances; inst != NULL; inst=inst->EKVnextInstance) {

			temp=inst->EKVtemp;

			switch (operation) {

			case N_OPEN:

				/* see if we have to to produce a summary report */
				/* if so, name all the noise generators */

			if (job->NStpsSm != 0) {
				switch (mode) {

				case N_DENS:
				for (i=0; i < EKVNSRCS; i++) {
					NOISE_ADD_OUTVAR(ckt, data, "onoise_%s%s", inst->EKVname, EKVnNames[i]);
				}
				break;

				case INT_NOIZ:
				for (i=0; i < EKVNSRCS; i++) {
					NOISE_ADD_OUTVAR(ckt, data, "onoise_total_%s%s", inst->EKVname, EKVnNames[i]);
					NOISE_ADD_OUTVAR(ckt, data, "inoise_total_%s%s", inst->EKVname, EKVnNames[i]);
				}
				break;
				}
			}
			break;


			case N_CALC:
				switch (mode) {

				case N_DENS:
					leff = inst->EKVl+model->EKVdl;
					weff = inst->EKVw+model->EKVdw;

					NevalSrcEKV(temp,model,inst,&noizDens[EKVRDNOIZ],&lnNdens[EKVRDNOIZ],
					    ckt,THERMNOISE,inst->EKVdNodePrime,inst->EKVdNode,
					    inst->EKVdrainConductance);

					NevalSrcEKV(temp,model,inst,&noizDens[EKVRSNOIZ],&lnNdens[EKVRSNOIZ],
					    ckt,THERMNOISE,inst->EKVsNodePrime,inst->EKVsNode,
					    inst->EKVsourceConductance);

					NevalSrcEKV(temp,model,inst,&noizDens[EKVIDNOIZ],&lnNdens[EKVIDNOIZ],
					    ckt,THERMNOISE,inst->EKVdNodePrime,inst->EKVsNodePrime,
					    (2.0/3.0 * fabs(inst->EKVgm)));

					NevalSrcEKV(temp,model,inst,&noizDens[EKVFLNOIZ],(double*)NULL,ckt,
					    N_GAIN,inst->EKVdNodePrime, inst->EKVsNodePrime,
					    (double)0.0);

					if (model->EKVnlevel==1)
						noizDens[EKVFLNOIZ] *= model->EKVfNcoef * 
						    exp(model->EKVfNexp *
						    log(MAX(fabs(inst->EKVcd),N_MINLOG))) /
						    data->freq / leff / leff / model->EKVcox;
					else
						noizDens[EKVFLNOIZ] *= model->EKVfNcoef *
						    model->EKVfNexp * inst->EKVgm * inst->EKVgm
						    / exp(model->EKVfNexp*log(data->freq)) / leff / weff 
						    / model->EKVcox;

					lnNdens[EKVFLNOIZ] = 
					    log(MAX(noizDens[EKVFLNOIZ],N_MINLOG));

					noizDens[EKVTOTNOIZ] = noizDens[EKVRDNOIZ] +
					    noizDens[EKVRSNOIZ] +
					    noizDens[EKVIDNOIZ] +
					    noizDens[EKVFLNOIZ];
					lnNdens[EKVTOTNOIZ] = 
					    log(MAX(noizDens[EKVTOTNOIZ], N_MINLOG));

					*OnDens += noizDens[EKVTOTNOIZ];

					if (data->delFreq == 0.0) {

						/* if we haven't done any previous integration, we need to */
						/* initialize our "history" variables                      */

						for (i=0; i < EKVNSRCS; i++) {
							inst->EKVnVar[LNLSTDENS][i] = lnNdens[i];
						}

						/* clear out our integration variables if it's the first pass */

						if (data->freq == ((NOISEAN*)ckt->CKTcurJob)->NstartFreq) {
							for (i=0; i < EKVNSRCS; i++) {
								inst->EKVnVar[OUTNOIZ][i] = 0.0;
								inst->EKVnVar[INNOIZ][i] = 0.0;
							}
						}
					} else {   /* data->delFreq != 0.0 (we have to integrate) */
						for (i=0; i < EKVNSRCS; i++) {
							if (i != EKVTOTNOIZ) {
								tempOnoise = Nintegrate(noizDens[i], lnNdens[i],
								    inst->EKVnVar[LNLSTDENS][i], data);
								tempInoise = Nintegrate(noizDens[i] * data->GainSqInv ,
								    lnNdens[i] + data->lnGainInv,
								    inst->EKVnVar[LNLSTDENS][i] + data->lnGainInv,
								    data);
								inst->EKVnVar[LNLSTDENS][i] = lnNdens[i];
								data->outNoiz += tempOnoise;
								data->inNoise += tempInoise;
								if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
/* code folded from here */
	inst->EKVnVar[OUTNOIZ][i] += tempOnoise;
	inst->EKVnVar[OUTNOIZ][EKVTOTNOIZ] += tempOnoise;
	inst->EKVnVar[INNOIZ][i] += tempInoise;
	inst->EKVnVar[INNOIZ][EKVTOTNOIZ] += tempInoise;
/* unfolding */
								}
							}
						}
					}
					if (data->prtSummary) {
						for (i=0; i < EKVNSRCS; i++) {     /* print a summary report */
							data->outpVector[data->outNumber++] = noizDens[i];
						}
					}
					break;

				case INT_NOIZ:        /* already calculated, just output */
					if (((NOISEAN*)ckt->CKTcurJob)->NStpsSm != 0) {
						for (i=0; i < EKVNSRCS; i++) {
							data->outpVector[data->outNumber++] = inst->EKVnVar[OUTNOIZ][i];
							data->outpVector[data->outNumber++] = inst->EKVnVar[INNOIZ][i];
						}
					}    /* if */
					break;
				}    /* switch (mode) */
				break;

			case N_CLOSE:
				return (OK);         /* do nothing, the main calling routine will close */
				break;               /* the plots */
			}    /* switch (operation) */
		}    /* for inst */
	}    /* for model */

	return(OK);
}
